"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});
exports.assertAnyTypeAnnotation = function (e, t) {
  a("AnyTypeAnnotation", e, t);
};
exports.assertArgumentPlaceholder = function (e, t) {
  a("ArgumentPlaceholder", e, t);
};
exports.assertArrayExpression = function (e, t) {
  a("ArrayExpression", e, t);
};
exports.assertArrayPattern = function (e, t) {
  a("ArrayPattern", e, t);
};
exports.assertArrayTypeAnnotation = function (e, t) {
  a("ArrayTypeAnnotation", e, t);
};
exports.assertArrowFunctionExpression = function (e, t) {
  a("ArrowFunctionExpression", e, t);
};
exports.assertAssignmentExpression = function (e, t) {
  a("AssignmentExpression", e, t);
};
exports.assertAssignmentPattern = function (e, t) {
  a("AssignmentPattern", e, t);
};
exports.assertAwaitExpression = function (e, t) {
  a("AwaitExpression", e, t);
};
exports.assertBigIntLiteral = function (e, t) {
  a("BigIntLiteral", e, t);
};
exports.assertBinary = function (e, t) {
  a("Binary", e, t);
};
exports.assertBinaryExpression = function (e, t) {
  a("BinaryExpression", e, t);
};
exports.assertBindExpression = function (e, t) {
  a("BindExpression", e, t);
};
exports.assertBlock = function (e, t) {
  a("Block", e, t);
};
exports.assertBlockParent = function (e, t) {
  a("BlockParent", e, t);
};
exports.assertBlockStatement = function (e, t) {
  a("BlockStatement", e, t);
};
exports.assertBooleanLiteral = function (e, t) {
  a("BooleanLiteral", e, t);
};
exports.assertBooleanLiteralTypeAnnotation = function (e, t) {
  a("BooleanLiteralTypeAnnotation", e, t);
};
exports.assertBooleanTypeAnnotation = function (e, t) {
  a("BooleanTypeAnnotation", e, t);
};
exports.assertBreakStatement = function (e, t) {
  a("BreakStatement", e, t);
};
exports.assertCallExpression = function (e, t) {
  a("CallExpression", e, t);
};
exports.assertCatchClause = function (e, t) {
  a("CatchClause", e, t);
};
exports.assertClass = function (e, t) {
  a("Class", e, t);
};
exports.assertClassBody = function (e, t) {
  a("ClassBody", e, t);
};
exports.assertClassDeclaration = function (e, t) {
  a("ClassDeclaration", e, t);
};
exports.assertClassExpression = function (e, t) {
  a("ClassExpression", e, t);
};
exports.assertClassImplements = function (e, t) {
  a("ClassImplements", e, t);
};
exports.assertClassMethod = function (e, t) {
  a("ClassMethod", e, t);
};
exports.assertClassPrivateMethod = function (e, t) {
  a("ClassPrivateMethod", e, t);
};
exports.assertClassPrivateProperty = function (e, t) {
  a("ClassPrivateProperty", e, t);
};
exports.assertClassProperty = function (e, t) {
  a("ClassProperty", e, t);
};
exports.assertCompletionStatement = function (e, t) {
  a("CompletionStatement", e, t);
};
exports.assertConditional = function (e, t) {
  a("Conditional", e, t);
};
exports.assertConditionalExpression = function (e, t) {
  a("ConditionalExpression", e, t);
};
exports.assertContinueStatement = function (e, t) {
  a("ContinueStatement", e, t);
};
exports.assertDebuggerStatement = function (e, t) {
  a("DebuggerStatement", e, t);
};
exports.assertDecimalLiteral = function (e, t) {
  a("DecimalLiteral", e, t);
};
exports.assertDeclaration = function (e, t) {
  a("Declaration", e, t);
};
exports.assertDeclareClass = function (e, t) {
  a("DeclareClass", e, t);
};
exports.assertDeclareExportAllDeclaration = function (e, t) {
  a("DeclareExportAllDeclaration", e, t);
};
exports.assertDeclareExportDeclaration = function (e, t) {
  a("DeclareExportDeclaration", e, t);
};
exports.assertDeclareFunction = function (e, t) {
  a("DeclareFunction", e, t);
};
exports.assertDeclareInterface = function (e, t) {
  a("DeclareInterface", e, t);
};
exports.assertDeclareModule = function (e, t) {
  a("DeclareModule", e, t);
};
exports.assertDeclareModuleExports = function (e, t) {
  a("DeclareModuleExports", e, t);
};
exports.assertDeclareOpaqueType = function (e, t) {
  a("DeclareOpaqueType", e, t);
};
exports.assertDeclareTypeAlias = function (e, t) {
  a("DeclareTypeAlias", e, t);
};
exports.assertDeclareVariable = function (e, t) {
  a("DeclareVariable", e, t);
};
exports.assertDeclaredPredicate = function (e, t) {
  a("DeclaredPredicate", e, t);
};
exports.assertDecorator = function (e, t) {
  a("Decorator", e, t);
};
exports.assertDirective = function (e, t) {
  a("Directive", e, t);
};
exports.assertDirectiveLiteral = function (e, t) {
  a("DirectiveLiteral", e, t);
};
exports.assertDoExpression = function (e, t) {
  a("DoExpression", e, t);
};
exports.assertDoWhileStatement = function (e, t) {
  a("DoWhileStatement", e, t);
};
exports.assertEmptyStatement = function (e, t) {
  a("EmptyStatement", e, t);
};
exports.assertEmptyTypeAnnotation = function (e, t) {
  a("EmptyTypeAnnotation", e, t);
};
exports.assertEnumBody = function (e, t) {
  a("EnumBody", e, t);
};
exports.assertEnumBooleanBody = function (e, t) {
  a("EnumBooleanBody", e, t);
};
exports.assertEnumBooleanMember = function (e, t) {
  a("EnumBooleanMember", e, t);
};
exports.assertEnumDeclaration = function (e, t) {
  a("EnumDeclaration", e, t);
};
exports.assertEnumDefaultedMember = function (e, t) {
  a("EnumDefaultedMember", e, t);
};
exports.assertEnumMember = function (e, t) {
  a("EnumMember", e, t);
};
exports.assertEnumNumberBody = function (e, t) {
  a("EnumNumberBody", e, t);
};
exports.assertEnumNumberMember = function (e, t) {
  a("EnumNumberMember", e, t);
};
exports.assertEnumStringBody = function (e, t) {
  a("EnumStringBody", e, t);
};
exports.assertEnumStringMember = function (e, t) {
  a("EnumStringMember", e, t);
};
exports.assertEnumSymbolBody = function (e, t) {
  a("EnumSymbolBody", e, t);
};
exports.assertExistsTypeAnnotation = function (e, t) {
  a("ExistsTypeAnnotation", e, t);
};
exports.assertExportAllDeclaration = function (e, t) {
  a("ExportAllDeclaration", e, t);
};
exports.assertExportDeclaration = function (e, t) {
  a("ExportDeclaration", e, t);
};
exports.assertExportDefaultDeclaration = function (e, t) {
  a("ExportDefaultDeclaration", e, t);
};
exports.assertExportDefaultSpecifier = function (e, t) {
  a("ExportDefaultSpecifier", e, t);
};
exports.assertExportNamedDeclaration = function (e, t) {
  a("ExportNamedDeclaration", e, t);
};
exports.assertExportNamespaceSpecifier = function (e, t) {
  a("ExportNamespaceSpecifier", e, t);
};
exports.assertExportSpecifier = function (e, t) {
  a("ExportSpecifier", e, t);
};
exports.assertExpression = function (e, t) {
  a("Expression", e, t);
};
exports.assertExpressionStatement = function (e, t) {
  a("ExpressionStatement", e, t);
};
exports.assertExpressionWrapper = function (e, t) {
  a("ExpressionWrapper", e, t);
};
exports.assertFile = function (e, t) {
  a("File", e, t);
};
exports.assertFlow = function (e, t) {
  a("Flow", e, t);
};
exports.assertFlowBaseAnnotation = function (e, t) {
  a("FlowBaseAnnotation", e, t);
};
exports.assertFlowDeclaration = function (e, t) {
  a("FlowDeclaration", e, t);
};
exports.assertFlowPredicate = function (e, t) {
  a("FlowPredicate", e, t);
};
exports.assertFlowType = function (e, t) {
  a("FlowType", e, t);
};
exports.assertFor = function (e, t) {
  a("For", e, t);
};
exports.assertForInStatement = function (e, t) {
  a("ForInStatement", e, t);
};
exports.assertForOfStatement = function (e, t) {
  a("ForOfStatement", e, t);
};
exports.assertForStatement = function (e, t) {
  a("ForStatement", e, t);
};
exports.assertForXStatement = function (e, t) {
  a("ForXStatement", e, t);
};
exports.assertFunction = function (e, t) {
  a("Function", e, t);
};
exports.assertFunctionDeclaration = function (e, t) {
  a("FunctionDeclaration", e, t);
};
exports.assertFunctionExpression = function (e, t) {
  a("FunctionExpression", e, t);
};
exports.assertFunctionParent = function (e, t) {
  a("FunctionParent", e, t);
};
exports.assertFunctionTypeAnnotation = function (e, t) {
  a("FunctionTypeAnnotation", e, t);
};
exports.assertFunctionTypeParam = function (e, t) {
  a("FunctionTypeParam", e, t);
};
exports.assertGenericTypeAnnotation = function (e, t) {
  a("GenericTypeAnnotation", e, t);
};
exports.assertIdentifier = function (e, t) {
  a("Identifier", e, t);
};
exports.assertIfStatement = function (e, t) {
  a("IfStatement", e, t);
};
exports.assertImmutable = function (e, t) {
  a("Immutable", e, t);
};
exports.assertImport = function (e, t) {
  a("Import", e, t);
};
exports.assertImportAttribute = function (e, t) {
  a("ImportAttribute", e, t);
};
exports.assertImportDeclaration = function (e, t) {
  a("ImportDeclaration", e, t);
};
exports.assertImportDefaultSpecifier = function (e, t) {
  a("ImportDefaultSpecifier", e, t);
};
exports.assertImportNamespaceSpecifier = function (e, t) {
  a("ImportNamespaceSpecifier", e, t);
};
exports.assertImportSpecifier = function (e, t) {
  a("ImportSpecifier", e, t);
};
exports.assertIndexedAccessType = function (e, t) {
  a("IndexedAccessType", e, t);
};
exports.assertInferredPredicate = function (e, t) {
  a("InferredPredicate", e, t);
};
exports.assertInterfaceDeclaration = function (e, t) {
  a("InterfaceDeclaration", e, t);
};
exports.assertInterfaceExtends = function (e, t) {
  a("InterfaceExtends", e, t);
};
exports.assertInterfaceTypeAnnotation = function (e, t) {
  a("InterfaceTypeAnnotation", e, t);
};
exports.assertInterpreterDirective = function (e, t) {
  a("InterpreterDirective", e, t);
};
exports.assertIntersectionTypeAnnotation = function (e, t) {
  a("IntersectionTypeAnnotation", e, t);
};
exports.assertJSX = function (e, t) {
  a("JSX", e, t);
};
exports.assertJSXAttribute = function (e, t) {
  a("JSXAttribute", e, t);
};
exports.assertJSXClosingElement = function (e, t) {
  a("JSXClosingElement", e, t);
};
exports.assertJSXClosingFragment = function (e, t) {
  a("JSXClosingFragment", e, t);
};
exports.assertJSXElement = function (e, t) {
  a("JSXElement", e, t);
};
exports.assertJSXEmptyExpression = function (e, t) {
  a("JSXEmptyExpression", e, t);
};
exports.assertJSXExpressionContainer = function (e, t) {
  a("JSXExpressionContainer", e, t);
};
exports.assertJSXFragment = function (e, t) {
  a("JSXFragment", e, t);
};
exports.assertJSXIdentifier = function (e, t) {
  a("JSXIdentifier", e, t);
};
exports.assertJSXMemberExpression = function (e, t) {
  a("JSXMemberExpression", e, t);
};
exports.assertJSXNamespacedName = function (e, t) {
  a("JSXNamespacedName", e, t);
};
exports.assertJSXOpeningElement = function (e, t) {
  a("JSXOpeningElement", e, t);
};
exports.assertJSXOpeningFragment = function (e, t) {
  a("JSXOpeningFragment", e, t);
};
exports.assertJSXSpreadAttribute = function (e, t) {
  a("JSXSpreadAttribute", e, t);
};
exports.assertJSXSpreadChild = function (e, t) {
  a("JSXSpreadChild", e, t);
};
exports.assertJSXText = function (e, t) {
  a("JSXText", e, t);
};
exports.assertLVal = function (e, t) {
  a("LVal", e, t);
};
exports.assertLabeledStatement = function (e, t) {
  a("LabeledStatement", e, t);
};
exports.assertLiteral = function (e, t) {
  a("Literal", e, t);
};
exports.assertLogicalExpression = function (e, t) {
  a("LogicalExpression", e, t);
};
exports.assertLoop = function (e, t) {
  a("Loop", e, t);
};
exports.assertMemberExpression = function (e, t) {
  a("MemberExpression", e, t);
};
exports.assertMetaProperty = function (e, t) {
  a("MetaProperty", e, t);
};
exports.assertMethod = function (e, t) {
  a("Method", e, t);
};
exports.assertMiscellaneous = function (e, t) {
  a("Miscellaneous", e, t);
};
exports.assertMixedTypeAnnotation = function (e, t) {
  a("MixedTypeAnnotation", e, t);
};
exports.assertModuleDeclaration = function (e, t) {
  a("ModuleDeclaration", e, t);
};
exports.assertModuleExpression = function (e, t) {
  a("ModuleExpression", e, t);
};
exports.assertModuleSpecifier = function (e, t) {
  a("ModuleSpecifier", e, t);
};
exports.assertNewExpression = function (e, t) {
  a("NewExpression", e, t);
};
exports.assertNoop = function (e, t) {
  a("Noop", e, t);
};
exports.assertNullLiteral = function (e, t) {
  a("NullLiteral", e, t);
};
exports.assertNullLiteralTypeAnnotation = function (e, t) {
  a("NullLiteralTypeAnnotation", e, t);
};
exports.assertNullableTypeAnnotation = function (e, t) {
  a("NullableTypeAnnotation", e, t);
};
exports.assertNumberLiteral = function (e, t) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  a("NumberLiteral", e, t);
};
exports.assertNumberLiteralTypeAnnotation = function (e, t) {
  a("NumberLiteralTypeAnnotation", e, t);
};
exports.assertNumberTypeAnnotation = function (e, t) {
  a("NumberTypeAnnotation", e, t);
};
exports.assertNumericLiteral = function (e, t) {
  a("NumericLiteral", e, t);
};
exports.assertObjectExpression = function (e, t) {
  a("ObjectExpression", e, t);
};
exports.assertObjectMember = function (e, t) {
  a("ObjectMember", e, t);
};
exports.assertObjectMethod = function (e, t) {
  a("ObjectMethod", e, t);
};
exports.assertObjectPattern = function (e, t) {
  a("ObjectPattern", e, t);
};
exports.assertObjectProperty = function (e, t) {
  a("ObjectProperty", e, t);
};
exports.assertObjectTypeAnnotation = function (e, t) {
  a("ObjectTypeAnnotation", e, t);
};
exports.assertObjectTypeCallProperty = function (e, t) {
  a("ObjectTypeCallProperty", e, t);
};
exports.assertObjectTypeIndexer = function (e, t) {
  a("ObjectTypeIndexer", e, t);
};
exports.assertObjectTypeInternalSlot = function (e, t) {
  a("ObjectTypeInternalSlot", e, t);
};
exports.assertObjectTypeProperty = function (e, t) {
  a("ObjectTypeProperty", e, t);
};
exports.assertObjectTypeSpreadProperty = function (e, t) {
  a("ObjectTypeSpreadProperty", e, t);
};
exports.assertOpaqueType = function (e, t) {
  a("OpaqueType", e, t);
};
exports.assertOptionalCallExpression = function (e, t) {
  a("OptionalCallExpression", e, t);
};
exports.assertOptionalIndexedAccessType = function (e, t) {
  a("OptionalIndexedAccessType", e, t);
};
exports.assertOptionalMemberExpression = function (e, t) {
  a("OptionalMemberExpression", e, t);
};
exports.assertParenthesizedExpression = function (e, t) {
  a("ParenthesizedExpression", e, t);
};
exports.assertPattern = function (e, t) {
  a("Pattern", e, t);
};
exports.assertPatternLike = function (e, t) {
  a("PatternLike", e, t);
};
exports.assertPipelineBareFunction = function (e, t) {
  a("PipelineBareFunction", e, t);
};
exports.assertPipelinePrimaryTopicReference = function (e, t) {
  a("PipelinePrimaryTopicReference", e, t);
};
exports.assertPipelineTopicExpression = function (e, t) {
  a("PipelineTopicExpression", e, t);
};
exports.assertPlaceholder = function (e, t) {
  a("Placeholder", e, t);
};
exports.assertPrivate = function (e, t) {
  a("Private", e, t);
};
exports.assertPrivateName = function (e, t) {
  a("PrivateName", e, t);
};
exports.assertProgram = function (e, t) {
  a("Program", e, t);
};
exports.assertProperty = function (e, t) {
  a("Property", e, t);
};
exports.assertPureish = function (e, t) {
  a("Pureish", e, t);
};
exports.assertQualifiedTypeIdentifier = function (e, t) {
  a("QualifiedTypeIdentifier", e, t);
};
exports.assertRecordExpression = function (e, t) {
  a("RecordExpression", e, t);
};
exports.assertRegExpLiteral = function (e, t) {
  a("RegExpLiteral", e, t);
};
exports.assertRegexLiteral = function (e, t) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  a("RegexLiteral", e, t);
};
exports.assertRestElement = function (e, t) {
  a("RestElement", e, t);
};
exports.assertRestProperty = function (e, t) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  a("RestProperty", e, t);
};
exports.assertReturnStatement = function (e, t) {
  a("ReturnStatement", e, t);
};
exports.assertScopable = function (e, t) {
  a("Scopable", e, t);
};
exports.assertSequenceExpression = function (e, t) {
  a("SequenceExpression", e, t);
};
exports.assertSpreadElement = function (e, t) {
  a("SpreadElement", e, t);
};
exports.assertSpreadProperty = function (e, t) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  a("SpreadProperty", e, t);
};
exports.assertStandardized = function (e, t) {
  a("Standardized", e, t);
};
exports.assertStatement = function (e, t) {
  a("Statement", e, t);
};
exports.assertStaticBlock = function (e, t) {
  a("StaticBlock", e, t);
};
exports.assertStringLiteral = function (e, t) {
  a("StringLiteral", e, t);
};
exports.assertStringLiteralTypeAnnotation = function (e, t) {
  a("StringLiteralTypeAnnotation", e, t);
};
exports.assertStringTypeAnnotation = function (e, t) {
  a("StringTypeAnnotation", e, t);
};
exports.assertSuper = function (e, t) {
  a("Super", e, t);
};
exports.assertSwitchCase = function (e, t) {
  a("SwitchCase", e, t);
};
exports.assertSwitchStatement = function (e, t) {
  a("SwitchStatement", e, t);
};
exports.assertSymbolTypeAnnotation = function (e, t) {
  a("SymbolTypeAnnotation", e, t);
};
exports.assertTSAnyKeyword = function (e, t) {
  a("TSAnyKeyword", e, t);
};
exports.assertTSArrayType = function (e, t) {
  a("TSArrayType", e, t);
};
exports.assertTSAsExpression = function (e, t) {
  a("TSAsExpression", e, t);
};
exports.assertTSBaseType = function (e, t) {
  a("TSBaseType", e, t);
};
exports.assertTSBigIntKeyword = function (e, t) {
  a("TSBigIntKeyword", e, t);
};
exports.assertTSBooleanKeyword = function (e, t) {
  a("TSBooleanKeyword", e, t);
};
exports.assertTSCallSignatureDeclaration = function (e, t) {
  a("TSCallSignatureDeclaration", e, t);
};
exports.assertTSConditionalType = function (e, t) {
  a("TSConditionalType", e, t);
};
exports.assertTSConstructSignatureDeclaration = function (e, t) {
  a("TSConstructSignatureDeclaration", e, t);
};
exports.assertTSConstructorType = function (e, t) {
  a("TSConstructorType", e, t);
};
exports.assertTSDeclareFunction = function (e, t) {
  a("TSDeclareFunction", e, t);
};
exports.assertTSDeclareMethod = function (e, t) {
  a("TSDeclareMethod", e, t);
};
exports.assertTSEntityName = function (e, t) {
  a("TSEntityName", e, t);
};
exports.assertTSEnumDeclaration = function (e, t) {
  a("TSEnumDeclaration", e, t);
};
exports.assertTSEnumMember = function (e, t) {
  a("TSEnumMember", e, t);
};
exports.assertTSExportAssignment = function (e, t) {
  a("TSExportAssignment", e, t);
};
exports.assertTSExpressionWithTypeArguments = function (e, t) {
  a("TSExpressionWithTypeArguments", e, t);
};
exports.assertTSExternalModuleReference = function (e, t) {
  a("TSExternalModuleReference", e, t);
};
exports.assertTSFunctionType = function (e, t) {
  a("TSFunctionType", e, t);
};
exports.assertTSImportEqualsDeclaration = function (e, t) {
  a("TSImportEqualsDeclaration", e, t);
};
exports.assertTSImportType = function (e, t) {
  a("TSImportType", e, t);
};
exports.assertTSIndexSignature = function (e, t) {
  a("TSIndexSignature", e, t);
};
exports.assertTSIndexedAccessType = function (e, t) {
  a("TSIndexedAccessType", e, t);
};
exports.assertTSInferType = function (e, t) {
  a("TSInferType", e, t);
};
exports.assertTSInterfaceBody = function (e, t) {
  a("TSInterfaceBody", e, t);
};
exports.assertTSInterfaceDeclaration = function (e, t) {
  a("TSInterfaceDeclaration", e, t);
};
exports.assertTSIntersectionType = function (e, t) {
  a("TSIntersectionType", e, t);
};
exports.assertTSIntrinsicKeyword = function (e, t) {
  a("TSIntrinsicKeyword", e, t);
};
exports.assertTSLiteralType = function (e, t) {
  a("TSLiteralType", e, t);
};
exports.assertTSMappedType = function (e, t) {
  a("TSMappedType", e, t);
};
exports.assertTSMethodSignature = function (e, t) {
  a("TSMethodSignature", e, t);
};
exports.assertTSModuleBlock = function (e, t) {
  a("TSModuleBlock", e, t);
};
exports.assertTSModuleDeclaration = function (e, t) {
  a("TSModuleDeclaration", e, t);
};
exports.assertTSNamedTupleMember = function (e, t) {
  a("TSNamedTupleMember", e, t);
};
exports.assertTSNamespaceExportDeclaration = function (e, t) {
  a("TSNamespaceExportDeclaration", e, t);
};
exports.assertTSNeverKeyword = function (e, t) {
  a("TSNeverKeyword", e, t);
};
exports.assertTSNonNullExpression = function (e, t) {
  a("TSNonNullExpression", e, t);
};
exports.assertTSNullKeyword = function (e, t) {
  a("TSNullKeyword", e, t);
};
exports.assertTSNumberKeyword = function (e, t) {
  a("TSNumberKeyword", e, t);
};
exports.assertTSObjectKeyword = function (e, t) {
  a("TSObjectKeyword", e, t);
};
exports.assertTSOptionalType = function (e, t) {
  a("TSOptionalType", e, t);
};
exports.assertTSParameterProperty = function (e, t) {
  a("TSParameterProperty", e, t);
};
exports.assertTSParenthesizedType = function (e, t) {
  a("TSParenthesizedType", e, t);
};
exports.assertTSPropertySignature = function (e, t) {
  a("TSPropertySignature", e, t);
};
exports.assertTSQualifiedName = function (e, t) {
  a("TSQualifiedName", e, t);
};
exports.assertTSRestType = function (e, t) {
  a("TSRestType", e, t);
};
exports.assertTSStringKeyword = function (e, t) {
  a("TSStringKeyword", e, t);
};
exports.assertTSSymbolKeyword = function (e, t) {
  a("TSSymbolKeyword", e, t);
};
exports.assertTSThisType = function (e, t) {
  a("TSThisType", e, t);
};
exports.assertTSTupleType = function (e, t) {
  a("TSTupleType", e, t);
};
exports.assertTSType = function (e, t) {
  a("TSType", e, t);
};
exports.assertTSTypeAliasDeclaration = function (e, t) {
  a("TSTypeAliasDeclaration", e, t);
};
exports.assertTSTypeAnnotation = function (e, t) {
  a("TSTypeAnnotation", e, t);
};
exports.assertTSTypeAssertion = function (e, t) {
  a("TSTypeAssertion", e, t);
};
exports.assertTSTypeElement = function (e, t) {
  a("TSTypeElement", e, t);
};
exports.assertTSTypeLiteral = function (e, t) {
  a("TSTypeLiteral", e, t);
};
exports.assertTSTypeOperator = function (e, t) {
  a("TSTypeOperator", e, t);
};
exports.assertTSTypeParameter = function (e, t) {
  a("TSTypeParameter", e, t);
};
exports.assertTSTypeParameterDeclaration = function (e, t) {
  a("TSTypeParameterDeclaration", e, t);
};
exports.assertTSTypeParameterInstantiation = function (e, t) {
  a("TSTypeParameterInstantiation", e, t);
};
exports.assertTSTypePredicate = function (e, t) {
  a("TSTypePredicate", e, t);
};
exports.assertTSTypeQuery = function (e, t) {
  a("TSTypeQuery", e, t);
};
exports.assertTSTypeReference = function (e, t) {
  a("TSTypeReference", e, t);
};
exports.assertTSUndefinedKeyword = function (e, t) {
  a("TSUndefinedKeyword", e, t);
};
exports.assertTSUnionType = function (e, t) {
  a("TSUnionType", e, t);
};
exports.assertTSUnknownKeyword = function (e, t) {
  a("TSUnknownKeyword", e, t);
};
exports.assertTSVoidKeyword = function (e, t) {
  a("TSVoidKeyword", e, t);
};
exports.assertTaggedTemplateExpression = function (e, t) {
  a("TaggedTemplateExpression", e, t);
};
exports.assertTemplateElement = function (e, t) {
  a("TemplateElement", e, t);
};
exports.assertTemplateLiteral = function (e, t) {
  a("TemplateLiteral", e, t);
};
exports.assertTerminatorless = function (e, t) {
  a("Terminatorless", e, t);
};
exports.assertThisExpression = function (e, t) {
  a("ThisExpression", e, t);
};
exports.assertThisTypeAnnotation = function (e, t) {
  a("ThisTypeAnnotation", e, t);
};
exports.assertThrowStatement = function (e, t) {
  a("ThrowStatement", e, t);
};
exports.assertTopicReference = function (e, t) {
  a("TopicReference", e, t);
};
exports.assertTryStatement = function (e, t) {
  a("TryStatement", e, t);
};
exports.assertTupleExpression = function (e, t) {
  a("TupleExpression", e, t);
};
exports.assertTupleTypeAnnotation = function (e, t) {
  a("TupleTypeAnnotation", e, t);
};
exports.assertTypeAlias = function (e, t) {
  a("TypeAlias", e, t);
};
exports.assertTypeAnnotation = function (e, t) {
  a("TypeAnnotation", e, t);
};
exports.assertTypeCastExpression = function (e, t) {
  a("TypeCastExpression", e, t);
};
exports.assertTypeParameter = function (e, t) {
  a("TypeParameter", e, t);
};
exports.assertTypeParameterDeclaration = function (e, t) {
  a("TypeParameterDeclaration", e, t);
};
exports.assertTypeParameterInstantiation = function (e, t) {
  a("TypeParameterInstantiation", e, t);
};
exports.assertTypeScript = function (e, t) {
  a("TypeScript", e, t);
};
exports.assertTypeofTypeAnnotation = function (e, t) {
  a("TypeofTypeAnnotation", e, t);
};
exports.assertUnaryExpression = function (e, t) {
  a("UnaryExpression", e, t);
};
exports.assertUnaryLike = function (e, t) {
  a("UnaryLike", e, t);
};
exports.assertUnionTypeAnnotation = function (e, t) {
  a("UnionTypeAnnotation", e, t);
};
exports.assertUpdateExpression = function (e, t) {
  a("UpdateExpression", e, t);
};
exports.assertUserWhitespacable = function (e, t) {
  a("UserWhitespacable", e, t);
};
exports.assertV8IntrinsicIdentifier = function (e, t) {
  a("V8IntrinsicIdentifier", e, t);
};
exports.assertVariableDeclaration = function (e, t) {
  a("VariableDeclaration", e, t);
};
exports.assertVariableDeclarator = function (e, t) {
  a("VariableDeclarator", e, t);
};
exports.assertVariance = function (e, t) {
  a("Variance", e, t);
};
exports.assertVoidTypeAnnotation = function (e, t) {
  a("VoidTypeAnnotation", e, t);
};
exports.assertWhile = function (e, t) {
  a("While", e, t);
};
exports.assertWhileStatement = function (e, t) {
  a("WhileStatement", e, t);
};
exports.assertWithStatement = function (e, t) {
  a("WithStatement", e, t);
};
exports.assertYieldExpression = function (e, t) {
  a("YieldExpression", e, t);
};
var r = require("./2678");
function a(e, t, n) {
  if (!(0, r.default)(e, t, n)) {
    throw new Error('Expected type "'.concat(e, '" with option ').concat(JSON.stringify(n), ", ") + 'but instead got "'.concat(t.type, '".'));
  }
}