"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});
exports.assertAnyTypeAnnotation = function (e, t) {
  i("AnyTypeAnnotation", e, t);
};
exports.assertArgumentPlaceholder = function (e, t) {
  i("ArgumentPlaceholder", e, t);
};
exports.assertArrayExpression = function (e, t) {
  i("ArrayExpression", e, t);
};
exports.assertArrayPattern = function (e, t) {
  i("ArrayPattern", e, t);
};
exports.assertArrayTypeAnnotation = function (e, t) {
  i("ArrayTypeAnnotation", e, t);
};
exports.assertArrowFunctionExpression = function (e, t) {
  i("ArrowFunctionExpression", e, t);
};
exports.assertAssignmentExpression = function (e, t) {
  i("AssignmentExpression", e, t);
};
exports.assertAssignmentPattern = function (e, t) {
  i("AssignmentPattern", e, t);
};
exports.assertAwaitExpression = function (e, t) {
  i("AwaitExpression", e, t);
};
exports.assertBigIntLiteral = function (e, t) {
  i("BigIntLiteral", e, t);
};
exports.assertBinary = function (e, t) {
  i("Binary", e, t);
};
exports.assertBinaryExpression = function (e, t) {
  i("BinaryExpression", e, t);
};
exports.assertBindExpression = function (e, t) {
  i("BindExpression", e, t);
};
exports.assertBlock = function (e, t) {
  i("Block", e, t);
};
exports.assertBlockParent = function (e, t) {
  i("BlockParent", e, t);
};
exports.assertBlockStatement = function (e, t) {
  i("BlockStatement", e, t);
};
exports.assertBooleanLiteral = function (e, t) {
  i("BooleanLiteral", e, t);
};
exports.assertBooleanLiteralTypeAnnotation = function (e, t) {
  i("BooleanLiteralTypeAnnotation", e, t);
};
exports.assertBooleanTypeAnnotation = function (e, t) {
  i("BooleanTypeAnnotation", e, t);
};
exports.assertBreakStatement = function (e, t) {
  i("BreakStatement", e, t);
};
exports.assertCallExpression = function (e, t) {
  i("CallExpression", e, t);
};
exports.assertCatchClause = function (e, t) {
  i("CatchClause", e, t);
};
exports.assertClass = function (e, t) {
  i("Class", e, t);
};
exports.assertClassBody = function (e, t) {
  i("ClassBody", e, t);
};
exports.assertClassDeclaration = function (e, t) {
  i("ClassDeclaration", e, t);
};
exports.assertClassExpression = function (e, t) {
  i("ClassExpression", e, t);
};
exports.assertClassImplements = function (e, t) {
  i("ClassImplements", e, t);
};
exports.assertClassMethod = function (e, t) {
  i("ClassMethod", e, t);
};
exports.assertClassPrivateMethod = function (e, t) {
  i("ClassPrivateMethod", e, t);
};
exports.assertClassPrivateProperty = function (e, t) {
  i("ClassPrivateProperty", e, t);
};
exports.assertClassProperty = function (e, t) {
  i("ClassProperty", e, t);
};
exports.assertCompletionStatement = function (e, t) {
  i("CompletionStatement", e, t);
};
exports.assertConditional = function (e, t) {
  i("Conditional", e, t);
};
exports.assertConditionalExpression = function (e, t) {
  i("ConditionalExpression", e, t);
};
exports.assertContinueStatement = function (e, t) {
  i("ContinueStatement", e, t);
};
exports.assertDebuggerStatement = function (e, t) {
  i("DebuggerStatement", e, t);
};
exports.assertDecimalLiteral = function (e, t) {
  i("DecimalLiteral", e, t);
};
exports.assertDeclaration = function (e, t) {
  i("Declaration", e, t);
};
exports.assertDeclareClass = function (e, t) {
  i("DeclareClass", e, t);
};
exports.assertDeclareExportAllDeclaration = function (e, t) {
  i("DeclareExportAllDeclaration", e, t);
};
exports.assertDeclareExportDeclaration = function (e, t) {
  i("DeclareExportDeclaration", e, t);
};
exports.assertDeclareFunction = function (e, t) {
  i("DeclareFunction", e, t);
};
exports.assertDeclareInterface = function (e, t) {
  i("DeclareInterface", e, t);
};
exports.assertDeclareModule = function (e, t) {
  i("DeclareModule", e, t);
};
exports.assertDeclareModuleExports = function (e, t) {
  i("DeclareModuleExports", e, t);
};
exports.assertDeclareOpaqueType = function (e, t) {
  i("DeclareOpaqueType", e, t);
};
exports.assertDeclareTypeAlias = function (e, t) {
  i("DeclareTypeAlias", e, t);
};
exports.assertDeclareVariable = function (e, t) {
  i("DeclareVariable", e, t);
};
exports.assertDeclaredPredicate = function (e, t) {
  i("DeclaredPredicate", e, t);
};
exports.assertDecorator = function (e, t) {
  i("Decorator", e, t);
};
exports.assertDirective = function (e, t) {
  i("Directive", e, t);
};
exports.assertDirectiveLiteral = function (e, t) {
  i("DirectiveLiteral", e, t);
};
exports.assertDoExpression = function (e, t) {
  i("DoExpression", e, t);
};
exports.assertDoWhileStatement = function (e, t) {
  i("DoWhileStatement", e, t);
};
exports.assertEmptyStatement = function (e, t) {
  i("EmptyStatement", e, t);
};
exports.assertEmptyTypeAnnotation = function (e, t) {
  i("EmptyTypeAnnotation", e, t);
};
exports.assertEnumBody = function (e, t) {
  i("EnumBody", e, t);
};
exports.assertEnumBooleanBody = function (e, t) {
  i("EnumBooleanBody", e, t);
};
exports.assertEnumBooleanMember = function (e, t) {
  i("EnumBooleanMember", e, t);
};
exports.assertEnumDeclaration = function (e, t) {
  i("EnumDeclaration", e, t);
};
exports.assertEnumDefaultedMember = function (e, t) {
  i("EnumDefaultedMember", e, t);
};
exports.assertEnumMember = function (e, t) {
  i("EnumMember", e, t);
};
exports.assertEnumNumberBody = function (e, t) {
  i("EnumNumberBody", e, t);
};
exports.assertEnumNumberMember = function (e, t) {
  i("EnumNumberMember", e, t);
};
exports.assertEnumStringBody = function (e, t) {
  i("EnumStringBody", e, t);
};
exports.assertEnumStringMember = function (e, t) {
  i("EnumStringMember", e, t);
};
exports.assertEnumSymbolBody = function (e, t) {
  i("EnumSymbolBody", e, t);
};
exports.assertExistsTypeAnnotation = function (e, t) {
  i("ExistsTypeAnnotation", e, t);
};
exports.assertExportAllDeclaration = function (e, t) {
  i("ExportAllDeclaration", e, t);
};
exports.assertExportDeclaration = function (e, t) {
  i("ExportDeclaration", e, t);
};
exports.assertExportDefaultDeclaration = function (e, t) {
  i("ExportDefaultDeclaration", e, t);
};
exports.assertExportDefaultSpecifier = function (e, t) {
  i("ExportDefaultSpecifier", e, t);
};
exports.assertExportNamedDeclaration = function (e, t) {
  i("ExportNamedDeclaration", e, t);
};
exports.assertExportNamespaceSpecifier = function (e, t) {
  i("ExportNamespaceSpecifier", e, t);
};
exports.assertExportSpecifier = function (e, t) {
  i("ExportSpecifier", e, t);
};
exports.assertExpression = function (e, t) {
  i("Expression", e, t);
};
exports.assertExpressionStatement = function (e, t) {
  i("ExpressionStatement", e, t);
};
exports.assertExpressionWrapper = function (e, t) {
  i("ExpressionWrapper", e, t);
};
exports.assertFile = function (e, t) {
  i("File", e, t);
};
exports.assertFlow = function (e, t) {
  i("Flow", e, t);
};
exports.assertFlowBaseAnnotation = function (e, t) {
  i("FlowBaseAnnotation", e, t);
};
exports.assertFlowDeclaration = function (e, t) {
  i("FlowDeclaration", e, t);
};
exports.assertFlowPredicate = function (e, t) {
  i("FlowPredicate", e, t);
};
exports.assertFlowType = function (e, t) {
  i("FlowType", e, t);
};
exports.assertFor = function (e, t) {
  i("For", e, t);
};
exports.assertForInStatement = function (e, t) {
  i("ForInStatement", e, t);
};
exports.assertForOfStatement = function (e, t) {
  i("ForOfStatement", e, t);
};
exports.assertForStatement = function (e, t) {
  i("ForStatement", e, t);
};
exports.assertForXStatement = function (e, t) {
  i("ForXStatement", e, t);
};
exports.assertFunction = function (e, t) {
  i("Function", e, t);
};
exports.assertFunctionDeclaration = function (e, t) {
  i("FunctionDeclaration", e, t);
};
exports.assertFunctionExpression = function (e, t) {
  i("FunctionExpression", e, t);
};
exports.assertFunctionParent = function (e, t) {
  i("FunctionParent", e, t);
};
exports.assertFunctionTypeAnnotation = function (e, t) {
  i("FunctionTypeAnnotation", e, t);
};
exports.assertFunctionTypeParam = function (e, t) {
  i("FunctionTypeParam", e, t);
};
exports.assertGenericTypeAnnotation = function (e, t) {
  i("GenericTypeAnnotation", e, t);
};
exports.assertIdentifier = function (e, t) {
  i("Identifier", e, t);
};
exports.assertIfStatement = function (e, t) {
  i("IfStatement", e, t);
};
exports.assertImmutable = function (e, t) {
  i("Immutable", e, t);
};
exports.assertImport = function (e, t) {
  i("Import", e, t);
};
exports.assertImportAttribute = function (e, t) {
  i("ImportAttribute", e, t);
};
exports.assertImportDeclaration = function (e, t) {
  i("ImportDeclaration", e, t);
};
exports.assertImportDefaultSpecifier = function (e, t) {
  i("ImportDefaultSpecifier", e, t);
};
exports.assertImportNamespaceSpecifier = function (e, t) {
  i("ImportNamespaceSpecifier", e, t);
};
exports.assertImportSpecifier = function (e, t) {
  i("ImportSpecifier", e, t);
};
exports.assertIndexedAccessType = function (e, t) {
  i("IndexedAccessType", e, t);
};
exports.assertInferredPredicate = function (e, t) {
  i("InferredPredicate", e, t);
};
exports.assertInterfaceDeclaration = function (e, t) {
  i("InterfaceDeclaration", e, t);
};
exports.assertInterfaceExtends = function (e, t) {
  i("InterfaceExtends", e, t);
};
exports.assertInterfaceTypeAnnotation = function (e, t) {
  i("InterfaceTypeAnnotation", e, t);
};
exports.assertInterpreterDirective = function (e, t) {
  i("InterpreterDirective", e, t);
};
exports.assertIntersectionTypeAnnotation = function (e, t) {
  i("IntersectionTypeAnnotation", e, t);
};
exports.assertJSX = function (e, t) {
  i("JSX", e, t);
};
exports.assertJSXAttribute = function (e, t) {
  i("JSXAttribute", e, t);
};
exports.assertJSXClosingElement = function (e, t) {
  i("JSXClosingElement", e, t);
};
exports.assertJSXClosingFragment = function (e, t) {
  i("JSXClosingFragment", e, t);
};
exports.assertJSXElement = function (e, t) {
  i("JSXElement", e, t);
};
exports.assertJSXEmptyExpression = function (e, t) {
  i("JSXEmptyExpression", e, t);
};
exports.assertJSXExpressionContainer = function (e, t) {
  i("JSXExpressionContainer", e, t);
};
exports.assertJSXFragment = function (e, t) {
  i("JSXFragment", e, t);
};
exports.assertJSXIdentifier = function (e, t) {
  i("JSXIdentifier", e, t);
};
exports.assertJSXMemberExpression = function (e, t) {
  i("JSXMemberExpression", e, t);
};
exports.assertJSXNamespacedName = function (e, t) {
  i("JSXNamespacedName", e, t);
};
exports.assertJSXOpeningElement = function (e, t) {
  i("JSXOpeningElement", e, t);
};
exports.assertJSXOpeningFragment = function (e, t) {
  i("JSXOpeningFragment", e, t);
};
exports.assertJSXSpreadAttribute = function (e, t) {
  i("JSXSpreadAttribute", e, t);
};
exports.assertJSXSpreadChild = function (e, t) {
  i("JSXSpreadChild", e, t);
};
exports.assertJSXText = function (e, t) {
  i("JSXText", e, t);
};
exports.assertLVal = function (e, t) {
  i("LVal", e, t);
};
exports.assertLabeledStatement = function (e, t) {
  i("LabeledStatement", e, t);
};
exports.assertLiteral = function (e, t) {
  i("Literal", e, t);
};
exports.assertLogicalExpression = function (e, t) {
  i("LogicalExpression", e, t);
};
exports.assertLoop = function (e, t) {
  i("Loop", e, t);
};
exports.assertMemberExpression = function (e, t) {
  i("MemberExpression", e, t);
};
exports.assertMetaProperty = function (e, t) {
  i("MetaProperty", e, t);
};
exports.assertMethod = function (e, t) {
  i("Method", e, t);
};
exports.assertMiscellaneous = function (e, t) {
  i("Miscellaneous", e, t);
};
exports.assertMixedTypeAnnotation = function (e, t) {
  i("MixedTypeAnnotation", e, t);
};
exports.assertModuleDeclaration = function (e, t) {
  i("ModuleDeclaration", e, t);
};
exports.assertModuleExpression = function (e, t) {
  i("ModuleExpression", e, t);
};
exports.assertModuleSpecifier = function (e, t) {
  i("ModuleSpecifier", e, t);
};
exports.assertNewExpression = function (e, t) {
  i("NewExpression", e, t);
};
exports.assertNoop = function (e, t) {
  i("Noop", e, t);
};
exports.assertNullLiteral = function (e, t) {
  i("NullLiteral", e, t);
};
exports.assertNullLiteralTypeAnnotation = function (e, t) {
  i("NullLiteralTypeAnnotation", e, t);
};
exports.assertNullableTypeAnnotation = function (e, t) {
  i("NullableTypeAnnotation", e, t);
};
exports.assertNumberLiteral = function (e, t) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  i("NumberLiteral", e, t);
};
exports.assertNumberLiteralTypeAnnotation = function (e, t) {
  i("NumberLiteralTypeAnnotation", e, t);
};
exports.assertNumberTypeAnnotation = function (e, t) {
  i("NumberTypeAnnotation", e, t);
};
exports.assertNumericLiteral = function (e, t) {
  i("NumericLiteral", e, t);
};
exports.assertObjectExpression = function (e, t) {
  i("ObjectExpression", e, t);
};
exports.assertObjectMember = function (e, t) {
  i("ObjectMember", e, t);
};
exports.assertObjectMethod = function (e, t) {
  i("ObjectMethod", e, t);
};
exports.assertObjectPattern = function (e, t) {
  i("ObjectPattern", e, t);
};
exports.assertObjectProperty = function (e, t) {
  i("ObjectProperty", e, t);
};
exports.assertObjectTypeAnnotation = function (e, t) {
  i("ObjectTypeAnnotation", e, t);
};
exports.assertObjectTypeCallProperty = function (e, t) {
  i("ObjectTypeCallProperty", e, t);
};
exports.assertObjectTypeIndexer = function (e, t) {
  i("ObjectTypeIndexer", e, t);
};
exports.assertObjectTypeInternalSlot = function (e, t) {
  i("ObjectTypeInternalSlot", e, t);
};
exports.assertObjectTypeProperty = function (e, t) {
  i("ObjectTypeProperty", e, t);
};
exports.assertObjectTypeSpreadProperty = function (e, t) {
  i("ObjectTypeSpreadProperty", e, t);
};
exports.assertOpaqueType = function (e, t) {
  i("OpaqueType", e, t);
};
exports.assertOptionalCallExpression = function (e, t) {
  i("OptionalCallExpression", e, t);
};
exports.assertOptionalIndexedAccessType = function (e, t) {
  i("OptionalIndexedAccessType", e, t);
};
exports.assertOptionalMemberExpression = function (e, t) {
  i("OptionalMemberExpression", e, t);
};
exports.assertParenthesizedExpression = function (e, t) {
  i("ParenthesizedExpression", e, t);
};
exports.assertPattern = function (e, t) {
  i("Pattern", e, t);
};
exports.assertPatternLike = function (e, t) {
  i("PatternLike", e, t);
};
exports.assertPipelineBareFunction = function (e, t) {
  i("PipelineBareFunction", e, t);
};
exports.assertPipelinePrimaryTopicReference = function (e, t) {
  i("PipelinePrimaryTopicReference", e, t);
};
exports.assertPipelineTopicExpression = function (e, t) {
  i("PipelineTopicExpression", e, t);
};
exports.assertPlaceholder = function (e, t) {
  i("Placeholder", e, t);
};
exports.assertPrivate = function (e, t) {
  i("Private", e, t);
};
exports.assertPrivateName = function (e, t) {
  i("PrivateName", e, t);
};
exports.assertProgram = function (e, t) {
  i("Program", e, t);
};
exports.assertProperty = function (e, t) {
  i("Property", e, t);
};
exports.assertPureish = function (e, t) {
  i("Pureish", e, t);
};
exports.assertQualifiedTypeIdentifier = function (e, t) {
  i("QualifiedTypeIdentifier", e, t);
};
exports.assertRecordExpression = function (e, t) {
  i("RecordExpression", e, t);
};
exports.assertRegExpLiteral = function (e, t) {
  i("RegExpLiteral", e, t);
};
exports.assertRegexLiteral = function (e, t) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  i("RegexLiteral", e, t);
};
exports.assertRestElement = function (e, t) {
  i("RestElement", e, t);
};
exports.assertRestProperty = function (e, t) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  i("RestProperty", e, t);
};
exports.assertReturnStatement = function (e, t) {
  i("ReturnStatement", e, t);
};
exports.assertScopable = function (e, t) {
  i("Scopable", e, t);
};
exports.assertSequenceExpression = function (e, t) {
  i("SequenceExpression", e, t);
};
exports.assertSpreadElement = function (e, t) {
  i("SpreadElement", e, t);
};
exports.assertSpreadProperty = function (e, t) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  i("SpreadProperty", e, t);
};
exports.assertStandardized = function (e, t) {
  i("Standardized", e, t);
};
exports.assertStatement = function (e, t) {
  i("Statement", e, t);
};
exports.assertStaticBlock = function (e, t) {
  i("StaticBlock", e, t);
};
exports.assertStringLiteral = function (e, t) {
  i("StringLiteral", e, t);
};
exports.assertStringLiteralTypeAnnotation = function (e, t) {
  i("StringLiteralTypeAnnotation", e, t);
};
exports.assertStringTypeAnnotation = function (e, t) {
  i("StringTypeAnnotation", e, t);
};
exports.assertSuper = function (e, t) {
  i("Super", e, t);
};
exports.assertSwitchCase = function (e, t) {
  i("SwitchCase", e, t);
};
exports.assertSwitchStatement = function (e, t) {
  i("SwitchStatement", e, t);
};
exports.assertSymbolTypeAnnotation = function (e, t) {
  i("SymbolTypeAnnotation", e, t);
};
exports.assertTSAnyKeyword = function (e, t) {
  i("TSAnyKeyword", e, t);
};
exports.assertTSArrayType = function (e, t) {
  i("TSArrayType", e, t);
};
exports.assertTSAsExpression = function (e, t) {
  i("TSAsExpression", e, t);
};
exports.assertTSBaseType = function (e, t) {
  i("TSBaseType", e, t);
};
exports.assertTSBigIntKeyword = function (e, t) {
  i("TSBigIntKeyword", e, t);
};
exports.assertTSBooleanKeyword = function (e, t) {
  i("TSBooleanKeyword", e, t);
};
exports.assertTSCallSignatureDeclaration = function (e, t) {
  i("TSCallSignatureDeclaration", e, t);
};
exports.assertTSConditionalType = function (e, t) {
  i("TSConditionalType", e, t);
};
exports.assertTSConstructSignatureDeclaration = function (e, t) {
  i("TSConstructSignatureDeclaration", e, t);
};
exports.assertTSConstructorType = function (e, t) {
  i("TSConstructorType", e, t);
};
exports.assertTSDeclareFunction = function (e, t) {
  i("TSDeclareFunction", e, t);
};
exports.assertTSDeclareMethod = function (e, t) {
  i("TSDeclareMethod", e, t);
};
exports.assertTSEntityName = function (e, t) {
  i("TSEntityName", e, t);
};
exports.assertTSEnumDeclaration = function (e, t) {
  i("TSEnumDeclaration", e, t);
};
exports.assertTSEnumMember = function (e, t) {
  i("TSEnumMember", e, t);
};
exports.assertTSExportAssignment = function (e, t) {
  i("TSExportAssignment", e, t);
};
exports.assertTSExpressionWithTypeArguments = function (e, t) {
  i("TSExpressionWithTypeArguments", e, t);
};
exports.assertTSExternalModuleReference = function (e, t) {
  i("TSExternalModuleReference", e, t);
};
exports.assertTSFunctionType = function (e, t) {
  i("TSFunctionType", e, t);
};
exports.assertTSImportEqualsDeclaration = function (e, t) {
  i("TSImportEqualsDeclaration", e, t);
};
exports.assertTSImportType = function (e, t) {
  i("TSImportType", e, t);
};
exports.assertTSIndexSignature = function (e, t) {
  i("TSIndexSignature", e, t);
};
exports.assertTSIndexedAccessType = function (e, t) {
  i("TSIndexedAccessType", e, t);
};
exports.assertTSInferType = function (e, t) {
  i("TSInferType", e, t);
};
exports.assertTSInterfaceBody = function (e, t) {
  i("TSInterfaceBody", e, t);
};
exports.assertTSInterfaceDeclaration = function (e, t) {
  i("TSInterfaceDeclaration", e, t);
};
exports.assertTSIntersectionType = function (e, t) {
  i("TSIntersectionType", e, t);
};
exports.assertTSIntrinsicKeyword = function (e, t) {
  i("TSIntrinsicKeyword", e, t);
};
exports.assertTSLiteralType = function (e, t) {
  i("TSLiteralType", e, t);
};
exports.assertTSMappedType = function (e, t) {
  i("TSMappedType", e, t);
};
exports.assertTSMethodSignature = function (e, t) {
  i("TSMethodSignature", e, t);
};
exports.assertTSModuleBlock = function (e, t) {
  i("TSModuleBlock", e, t);
};
exports.assertTSModuleDeclaration = function (e, t) {
  i("TSModuleDeclaration", e, t);
};
exports.assertTSNamedTupleMember = function (e, t) {
  i("TSNamedTupleMember", e, t);
};
exports.assertTSNamespaceExportDeclaration = function (e, t) {
  i("TSNamespaceExportDeclaration", e, t);
};
exports.assertTSNeverKeyword = function (e, t) {
  i("TSNeverKeyword", e, t);
};
exports.assertTSNonNullExpression = function (e, t) {
  i("TSNonNullExpression", e, t);
};
exports.assertTSNullKeyword = function (e, t) {
  i("TSNullKeyword", e, t);
};
exports.assertTSNumberKeyword = function (e, t) {
  i("TSNumberKeyword", e, t);
};
exports.assertTSObjectKeyword = function (e, t) {
  i("TSObjectKeyword", e, t);
};
exports.assertTSOptionalType = function (e, t) {
  i("TSOptionalType", e, t);
};
exports.assertTSParameterProperty = function (e, t) {
  i("TSParameterProperty", e, t);
};
exports.assertTSParenthesizedType = function (e, t) {
  i("TSParenthesizedType", e, t);
};
exports.assertTSPropertySignature = function (e, t) {
  i("TSPropertySignature", e, t);
};
exports.assertTSQualifiedName = function (e, t) {
  i("TSQualifiedName", e, t);
};
exports.assertTSRestType = function (e, t) {
  i("TSRestType", e, t);
};
exports.assertTSStringKeyword = function (e, t) {
  i("TSStringKeyword", e, t);
};
exports.assertTSSymbolKeyword = function (e, t) {
  i("TSSymbolKeyword", e, t);
};
exports.assertTSThisType = function (e, t) {
  i("TSThisType", e, t);
};
exports.assertTSTupleType = function (e, t) {
  i("TSTupleType", e, t);
};
exports.assertTSType = function (e, t) {
  i("TSType", e, t);
};
exports.assertTSTypeAliasDeclaration = function (e, t) {
  i("TSTypeAliasDeclaration", e, t);
};
exports.assertTSTypeAnnotation = function (e, t) {
  i("TSTypeAnnotation", e, t);
};
exports.assertTSTypeAssertion = function (e, t) {
  i("TSTypeAssertion", e, t);
};
exports.assertTSTypeElement = function (e, t) {
  i("TSTypeElement", e, t);
};
exports.assertTSTypeLiteral = function (e, t) {
  i("TSTypeLiteral", e, t);
};
exports.assertTSTypeOperator = function (e, t) {
  i("TSTypeOperator", e, t);
};
exports.assertTSTypeParameter = function (e, t) {
  i("TSTypeParameter", e, t);
};
exports.assertTSTypeParameterDeclaration = function (e, t) {
  i("TSTypeParameterDeclaration", e, t);
};
exports.assertTSTypeParameterInstantiation = function (e, t) {
  i("TSTypeParameterInstantiation", e, t);
};
exports.assertTSTypePredicate = function (e, t) {
  i("TSTypePredicate", e, t);
};
exports.assertTSTypeQuery = function (e, t) {
  i("TSTypeQuery", e, t);
};
exports.assertTSTypeReference = function (e, t) {
  i("TSTypeReference", e, t);
};
exports.assertTSUndefinedKeyword = function (e, t) {
  i("TSUndefinedKeyword", e, t);
};
exports.assertTSUnionType = function (e, t) {
  i("TSUnionType", e, t);
};
exports.assertTSUnknownKeyword = function (e, t) {
  i("TSUnknownKeyword", e, t);
};
exports.assertTSVoidKeyword = function (e, t) {
  i("TSVoidKeyword", e, t);
};
exports.assertTaggedTemplateExpression = function (e, t) {
  i("TaggedTemplateExpression", e, t);
};
exports.assertTemplateElement = function (e, t) {
  i("TemplateElement", e, t);
};
exports.assertTemplateLiteral = function (e, t) {
  i("TemplateLiteral", e, t);
};
exports.assertTerminatorless = function (e, t) {
  i("Terminatorless", e, t);
};
exports.assertThisExpression = function (e, t) {
  i("ThisExpression", e, t);
};
exports.assertThisTypeAnnotation = function (e, t) {
  i("ThisTypeAnnotation", e, t);
};
exports.assertThrowStatement = function (e, t) {
  i("ThrowStatement", e, t);
};
exports.assertTopicReference = function (e, t) {
  i("TopicReference", e, t);
};
exports.assertTryStatement = function (e, t) {
  i("TryStatement", e, t);
};
exports.assertTupleExpression = function (e, t) {
  i("TupleExpression", e, t);
};
exports.assertTupleTypeAnnotation = function (e, t) {
  i("TupleTypeAnnotation", e, t);
};
exports.assertTypeAlias = function (e, t) {
  i("TypeAlias", e, t);
};
exports.assertTypeAnnotation = function (e, t) {
  i("TypeAnnotation", e, t);
};
exports.assertTypeCastExpression = function (e, t) {
  i("TypeCastExpression", e, t);
};
exports.assertTypeParameter = function (e, t) {
  i("TypeParameter", e, t);
};
exports.assertTypeParameterDeclaration = function (e, t) {
  i("TypeParameterDeclaration", e, t);
};
exports.assertTypeParameterInstantiation = function (e, t) {
  i("TypeParameterInstantiation", e, t);
};
exports.assertTypeScript = function (e, t) {
  i("TypeScript", e, t);
};
exports.assertTypeofTypeAnnotation = function (e, t) {
  i("TypeofTypeAnnotation", e, t);
};
exports.assertUnaryExpression = function (e, t) {
  i("UnaryExpression", e, t);
};
exports.assertUnaryLike = function (e, t) {
  i("UnaryLike", e, t);
};
exports.assertUnionTypeAnnotation = function (e, t) {
  i("UnionTypeAnnotation", e, t);
};
exports.assertUpdateExpression = function (e, t) {
  i("UpdateExpression", e, t);
};
exports.assertUserWhitespacable = function (e, t) {
  i("UserWhitespacable", e, t);
};
exports.assertV8IntrinsicIdentifier = function (e, t) {
  i("V8IntrinsicIdentifier", e, t);
};
exports.assertVariableDeclaration = function (e, t) {
  i("VariableDeclaration", e, t);
};
exports.assertVariableDeclarator = function (e, t) {
  i("VariableDeclarator", e, t);
};
exports.assertVariance = function (e, t) {
  i("Variance", e, t);
};
exports.assertVoidTypeAnnotation = function (e, t) {
  i("VoidTypeAnnotation", e, t);
};
exports.assertWhile = function (e, t) {
  i("While", e, t);
};
exports.assertWhileStatement = function (e, t) {
  i("WhileStatement", e, t);
};
exports.assertWithStatement = function (e, t) {
  i("WithStatement", e, t);
};
exports.assertYieldExpression = function (e, t) {
  i("YieldExpression", e, t);
};
var r = require("./2670");
function i(e, t, n) {
  if (!(0, r.default)(e, t, n)) {
    throw new Error('Expected type "'.concat(e, '" with option ').concat(JSON.stringify(n), ", ") + 'but instead got "'.concat(t.type, '".'));
  }
}